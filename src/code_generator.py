"""
ChocoPy Code Generator Implementation
Generates RISC-V assembly code from type-checked AST
"""

from typing import Dict, List, Optional, Set
from ast_nodes import *

class CodeGenerator:
    def __init__(self):
        self.output = []
        self.label_counter = 0
        self.string_literals = {}
        self.current_offset = 0
        self.local_vars = {}
        
    def generate(self, program: Program) -> str:
        """Generate RISC-V assembly for the program"""
        self._emit_header()
        self._emit_data_section()
        self._emit_text_section()
        
        # Generate code for global declarations and statements
        for decl in program.declarations:
            if isinstance(decl, FuncDef):
                self._generate_function(decl)
        
        # Generate main code
        if program.statements:
            self._emit_label("main")
            for stmt in program.statements:
                self._generate_statement(stmt)
            
            # Exit program
            self._emit("li a0, 0")
            self._emit("li a7, 93")  # exit syscall
            self._emit("ecall")
        
        self._emit_builtins()
        
        return '\n'.join(self.output)
    
    def _emit(self, instruction: str):
        """Emit an instruction"""
        self.output.append(f"    {instruction}")
    
    def _emit_label(self, label: str):
        """Emit a label"""
        self.output.append(f"{label}:")
    
    def _emit_comment(self, comment: str):
        """Emit a comment"""
        self.output.append(f"    # {comment}")
    
    def _new_label(self, prefix: str = "L") -> str:
        """Generate a new unique label"""
        label = f"{prefix}{self.label_counter}"
        self.label_counter += 1
        return label
    
    def _emit_header(self):
        """Emit file header"""
        self.output.append("# ChocoPy RISC-V Assembly")
        self.output.append("# Generated by ChocoPy Compiler")
        self.output.append("")
    
    def _emit_data_section(self):
        """Emit data section"""
        self.output.append(".data")
        self.output.append("")
        
        # Emit string literals
        for literal, label in self.string_literals.items():
            self.output.append(f"{label}: .asciz \"{literal}\"")
        
        self.output.append("")
    
    def _emit_text_section(self):
        """Emit text section header"""
        self.output.append(".text")
        self.output.append(".global main")
        self.output.append("")
    
    def _generate_function(self, func_def: FuncDef):
        """Generate code for a function"""
        self._emit_label(func_def.name)
        self._emit_comment(f"Function: {func_def.name}")
        
        # Function prologue
        self._emit("addi sp, sp, -16")
        self._emit("sw ra, 12(sp)")
        self._emit("sw fp, 8(sp)")
        self._emit("addi fp, sp, 16")
        
        # Initialize local variables
        self.local_vars = {}
        self.current_offset = 0
        
        # Allocate space for parameters
        for i, param in enumerate(func_def.params):
            offset = -(i + 1) * 4
            self.local_vars[param.identifier] = offset
        
        # Generate function body
        for stmt in func_def.statements:
            self._generate_statement(stmt)
        
        # Function epilogue (if no explicit return)
        self._emit_comment("Function epilogue")
        self._emit("li a0, 0")  # Default return value
        self._emit("lw ra, 12(sp)")
        self._emit("lw fp, 8(sp)")
        self._emit("addi sp, sp, 16")
        self._emit("jr ra")
        self.output.append("")
    
    def _generate_statement(self, stmt: Statement):
        """Generate code for a statement"""
        if isinstance(stmt, ExprStmt):
            self._generate_expression(stmt.expr)
        elif isinstance(stmt, AssignStmt):
            self._generate_assignment(stmt)
        elif isinstance(stmt, IfStmt):
            self._generate_if_stmt(stmt)
        elif isinstance(stmt, WhileStmt):
            self._generate_while_stmt(stmt)
        elif isinstance(stmt, ReturnStmt):
            self._generate_return_stmt(stmt)
        elif isinstance(stmt, PassStmt):
            self._emit_comment("pass statement")
        else:
            self._emit_comment(f"Unsupported statement: {type(stmt)}")
    
    def _generate_assignment(self, stmt: AssignStmt):
        """Generate code for assignment"""
        # Generate value
        self._generate_expression(stmt.value)
        
        # Store to all targets
        for target in stmt.targets:
            if isinstance(target, Identifier):
                # Simple variable assignment
                if target.name not in self.local_vars:
                    # Allocate new local variable
                    self.current_offset -= 4
                    self.local_vars[target.name] = self.current_offset
                    self._emit("addi sp, sp, -4")
                
                offset = self.local_vars[target.name]
                self._emit(f"sw a0, {offset}(fp)")
                self._emit_comment(f"Store to {target.name}")
    
    def _generate_if_stmt(self, stmt: IfStmt):
        """Generate code for if statement"""
        else_label = self._new_label("else")
        end_label = self._new_label("endif")
        
        # Generate condition
        self._generate_expression(stmt.condition)
        self._emit(f"beq a0, zero, {else_label}")
        
        # Generate then body
        for then_stmt in stmt.then_body:
            self._generate_statement(then_stmt)
        self._emit(f"j {end_label}")
        
        # Generate else body
        self._emit_label(else_label)
        if stmt.else_body:
            for else_stmt in stmt.else_body:
                self._generate_statement(else_stmt)
        
        self._emit_label(end_label)
    
    def _generate_while_stmt(self, stmt: WhileStmt):
        """Generate code for while statement"""
        loop_label = self._new_label("loop")
        end_label = self._new_label("endloop")
        
        self._emit_label(loop_label)
        
        # Generate condition
        self._generate_expression(stmt.condition)
        self._emit(f"beq a0, zero, {end_label}")
        
        # Generate body
        for body_stmt in stmt.body:
            self._generate_statement(body_stmt)
        
        self._emit(f"j {loop_label}")
        self._emit_label(end_label)
    
    def _generate_return_stmt(self, stmt: ReturnStmt):
        """Generate code for return statement"""
        if stmt.value:
            self._generate_expression(stmt.value)
        else:
            self._emit("li a0, 0")
        
        # Function epilogue
        self._emit("lw ra, 12(sp)")
        self._emit("lw fp, 8(sp)")
        self._emit("addi sp, sp, 16")
        self._emit("jr ra")
    
    def _generate_expression(self, expr: Expr):
        """Generate code for expression, result in a0"""
        if isinstance(expr, IntegerLiteral):
            self._emit(f"li a0, {expr.value}")
        elif isinstance(expr, BooleanLiteral):
            value = 1 if expr.value else 0
            self._emit(f"li a0, {value}")
        elif isinstance(expr, StringLiteral):
            label = self._get_string_label(expr.value)
            self._emit(f"la a0, {label}")
        elif isinstance(expr, Identifier):
            self._generate_identifier(expr)
        elif isinstance(expr, BinaryOp):
            self._generate_binary_op(expr)
        elif isinstance(expr, UnaryOp):
            self._generate_unary_op(expr)
        elif isinstance(expr, CallExpr):
            self._generate_call(expr)
        else:
            self._emit_comment(f"Unsupported expression: {type(expr)}")
            self._emit("li a0, 0")
    
    def _generate_identifier(self, identifier: Identifier):
        """Generate code for variable access"""
        if identifier.name in self.local_vars:
            offset = self.local_vars[identifier.name]
            self._emit(f"lw a0, {offset}(fp)")
            self._emit_comment(f"Load {identifier.name}")
        else:
            self._emit_comment(f"Undefined variable: {identifier.name}")
            self._emit("li a0, 0")
    
    def _generate_binary_op(self, binary_op: BinaryOp):
        """Generate code for binary operation"""
        # Generate left operand
        self._generate_expression(binary_op.left)
        self._emit("addi sp, sp, -4")
        self._emit("sw a0, 0(sp)")
        
        # Generate right operand
        self._generate_expression(binary_op.right)
        
        # Load left operand
        self._emit("lw a1, 0(sp)")
        self._emit("addi sp, sp, 4")
        
        # Perform operation
        op = binary_op.operator
        if op == '+':
            self._emit("add a0, a1, a0")
        elif op == '-':
            self._emit("sub a0, a1, a0")
        elif op == '*':
            self._emit("mul a0, a1, a0")
        elif op == '//':
            self._emit("div a0, a1, a0")
        elif op == '%':
            self._emit("rem a0, a1, a0")
        elif op == '==':
            self._emit("sub a0, a1, a0")
            self._emit("seqz a0, a0")
        elif op == '!=':
            self._emit("sub a0, a1, a0")
            self._emit("snez a0, a0")
        elif op == '<':
            self._emit("slt a0, a1, a0")
        elif op == '<=':
            self._emit("slt a0, a0, a1")
            self._emit("xori a0, a0, 1")
        elif op == '>':
            self._emit("slt a0, a0, a1")
        elif op == '>=':
            self._emit("slt a0, a1, a0")
            self._emit("xori a0, a0, 1")
        else:
            self._emit_comment(f"Unsupported binary operator: {op}")
    
    def _generate_unary_op(self, unary_op: UnaryOp):
        """Generate code for unary operation"""
        self._generate_expression(unary_op.operand)
        
        if unary_op.operator == '-':
            self._emit("neg a0, a0")
        elif unary_op.operator == 'not':
            self._emit("seqz a0, a0")
        else:
            self._emit_comment(f"Unsupported unary operator: {unary_op.operator}")
    
    def _generate_call(self, call_expr: CallExpr):
        """Generate code for function call"""
        if isinstance(call_expr.function, Identifier):
            func_name = call_expr.function.name
            
            # Built-in functions
            if func_name == "print":
                if call_expr.args:
                    self._generate_expression(call_expr.args[0])
                    self._emit("jal print_int")
                self._emit("li a0, 0")
            elif func_name == "len":
                self._emit_comment("len() not fully implemented")
                self._emit("li a0, 0")
            else:
                # User-defined function
                for i, arg in enumerate(call_expr.args):
                    self._generate_expression(arg)
                    self._emit("addi sp, sp, -4")
                    self._emit("sw a0, 0(sp)")
                
                self._emit(f"jal {func_name}")
                
                # Clean up arguments
                if call_expr.args:
                    self._emit(f"addi sp, sp, {len(call_expr.args) * 4}")
    
    def _get_string_label(self, literal: str) -> str:
        """Get or create label for string literal"""
        if literal not in self.string_literals:
            label = f"str_{len(self.string_literals)}"
            self.string_literals[literal] = label
        return self.string_literals[literal]
    
    def _emit_builtins(self):
        """Emit built-in function implementations"""
        self.output.append("")
        self._emit_comment("Built-in functions")
        
        # print_int function
        self._emit_label("print_int")
        self._emit("li a7, 1")      # print integer syscall
        self._emit("ecall")
        self._emit("li a7, 11")     # print character syscall
        self._emit("li a0, 10")     # newline character
        self._emit("ecall")
        self._emit("jr ra")